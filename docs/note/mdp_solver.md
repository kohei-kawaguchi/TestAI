# AIをRAとして活用する：モデルの均衡計算の実装事例

## はじめに

前回の記事では、因果推論の実装をAIに依頼する「口頭試問方式」を紹介しました。今回は、経済学研究におけるもう一つの重要なタスク——**モデルの均衡計算**——にこのアプローチを適用します。

具体的には、動的最適化の基本問題である**マルコフ意思決定過程（MDP）の最適方策の導出**をAIに実装させました。この問題は、資産蓄積、労働供給、企業の投資決定など、経済学で広く応用されています。

重要なのは、この基本的な枠組みを理解すれば、より複雑な問題——ゲーム理論的な戦略的相互作用、不完備情報下での意思決定、異質なエージェント間の均衡——にも同じ方法論で対処できるということです。コンセプトは共通しています：**モデルの数理的定式化 → 解法の設計 → 実装 → 検証 → 妥当性確認**というプロセスです。

## 「数式」をSingle Source of Truthとする

前回の記事で強調した口頭試問方式を、今回はさらに進化させます。**モデルの設定と解法を数式と疑似コードで明示的に記述してから、それをsingle source of truth（唯一の真実の源）として、すべての実装を進めていく**という方法論です。

### なぜ数式が必要か

モデルの均衡計算では「何を計算すべきか」がAIにとって自明ではありません。Bellman方程式、価値関数、最適方策——これらの数学的定義が曖昧なまま実装を始めると、AIは間違った方向に進んでしまいます。

そこで、実装の前に以下を明確にします：

1. **数理モデルの完全な定式化**：状態、行動、報酬、遷移のすべてを数式で記述
2. **解法アルゴリズムの疑似コード**：計算手順を、数式とプログラムの中間言語で表現
3. **疑似コードを実装の仕様書とする**：AIはこれを見ながらコードを書く
4. **単体テストも疑似コードから生成**：各ステップが正しく実装されているかを検証

この方法の最大の利点は、**変更管理が容易になる**ことです。例えば、報酬関数の関数形を変更する場合：

1. まず数式を更新（文書レベル）
2. 次に疑似コードを更新（仕様レベル）
3. その後、実装を更新（コードレベル）
4. テストを更新（verification: 仕様通りに動くか）

この順序を守ることで、文書と実装の乖離を防げます。AIに「まだコードを変更しないでください」と明示的に指示することも重要です。

## 疑似コードの品質が成否を分ける

AIに数式から直接コードを書かせることもできますが、それでは中間的な検証ができません。そこで、**数式とコードの間に「疑似コード」という橋渡しを置きます**。

疑似コードは、数学とプログラミングの両方の要素を持つ記述です。数学的には厳密でありながら、プログラミング的には実装可能な形で書かれています。

### 疑似コードに求められる品質

AIが最初に生成する疑似コードには、しばしば曖昧な記述が含まれます。`// Implementation details` や `// TODO: Compute targets` といったプレースホルダーです。

これらは**すべて排除**します。疑似コードは「これから実装する」ためのメモではなく、「AIが実装できるだけの情報を持つ仕様書」でなければなりません。

具体的には、プレースホルダーをゼロにし、型情報を明記し、関数を小さく分割し、動詞ベースで命名します（ComputeX, FitY, SolveZ）。そして、すべての関数呼び出しで名前付き引数を強制します：`func(beta=0.5, gamma=0.1)` という形式です。

パラメータの順序を間違えるバグは、AIでも人間でも頻発します。これをプロジェクトのルール（CLAUDE.md）に明記することで、一貫性が保たれます。

### 疑似コードから実装とテストを生成

疑似コードが完成すれば、実装とテストは機械的に導出できます。各疑似コードの手続き（Procedure）が、Pythonの関数と対応するテストクラスになります。テストの内容も疑似コードから導出されます。「r(s,a) = β·log(1+s) - aを返す」という仕様があれば、実際にその式で計算した値と関数の出力が一致するかをテストします。

今回は45個の単体テストを作成し、すべてパスすることを確認しました。これにより、各計算ステップが仕様通りに動作していることが保証されます。

## 段階的変更管理の重要性

実装の途中で、報酬関数の関数形を変更する必要が生じました。単純な線形形 (β·s - a) から、収穫逓減を表現する対数形 (β·log(1+s) - a) への変更です。

ここで重要なのは、**変更の順序**です。まず数式の文書を更新し、経済学的解釈を追加し、Bellman方程式を更新し、疑似コードを更新します。その上で、AIに「まだ実装を変更しないでください」と明示的に指示します。ユーザーの許可を得てから実装を更新し、最後にテストを更新します。

AIは指示されればすぐにコードを書き換えますが、それでは文書との同期が取れません。明示的に「待て」と指示することで、段階的な更新が可能になります。

## 比較静学によるValidation

モデル実装の検証において、**比較静学（comparative statics）分析は不可欠**です。

単体テストは「個々の関数が正しく動くか」を検証します。しかし、それだけでは不十分です。モデル全体として「経済学的に意味のある結果を出すか」を確認する必要があります。

そこで、重要パラメータを系統的に変化させ、結果が理論的予測と整合するかを検証します。

### なぜ比較静学が不可欠か

今回のMDP問題では、β（報酬の重み）とγ（減価率）という2つのパラメータに注目しました。これらを系統的に変化させた結果、βが増加すると価値関数が上昇し状態依存的な閾値方策が出現すること、γが増加すると価値関数が減少し補充型の方策にシフトすることが確認されました。

これらの結果は経済学的に妥当です。もし逆の結果（βが増えると価値が下がる、など）が出たら、実装のどこかに誤りがあります。

比較静学は、**単体テストでは捕捉できない、モデル全体のロジックの誤り**を発見します。個々の関数は正しくても、それらの組み合わせ方が間違っていれば、比較静学で異常な結果が出ます。

### 可視化の重要性

比較静学の結果は、複数のパラメータ値での価値関数と方策を重ね描きすることで可視化しました。カラーグラデーション（パラメータ値が増えるにつれて黒→青、黒→赤）を使うことで、連続的な変化を直感的に理解できます。

定量的な数値だけでなく、視覚的にパターンを確認することで、実装の妥当性に対する確信が深まります。

## 会話履歴の記録と事後的学習

前回同様、AIとの会話履歴を完全に記録し、[`docs/conversation/mdp_solver_conversation_transcript.md`](../../conversation/mdp_solver_conversation_transcript.md)として公開しています。

会話履歴は、単なる記録以上の価値があります。プロジェクトの再現性（どのような指示でこの結果が得られたか）を保証するだけでなく、ノウハウの共有（どの段階でどのような質問をすべきか）を可能にし、自己改善のツール（会話履歴とgitコミット履歴をAIに評価させて監督の仕方を改善）として機能します。

今回の会話履歴は、11のフェーズに構造化されています。各フェーズには「Key Learning」セクションがあり、なぜその選択をしたのか（例：なぜ名前付き引数を強制するか）が記録されています。

## まとめ：AIによるモデル実装の方法論

本実装事例は、前回の因果推論からさらに進んで、**モデルの均衡計算**をAIに実装させる方法論を示しました。

### 核心的な原則

1. **数式をsingle source of truthとする**
   数学的定式化 → 疑似コード → 実装 → テスト の一貫した流れを作る。変更は常に上流（数式・疑似コード）から始める。

2. **疑似コードの品質管理**
   プレースホルダーを排除し、型情報を明記し、関数を小さく分割する。疑似コードは「これから書く」メモではなく「AIが実装できる仕様書」である。

3. **段階的変更管理**
   AIは指示されればすぐコードを書き換える。だからこそ、「待て」と明示的に指示し、文書→実装の順序を守る。

4. **比較静学による検証**
   単体テストは関数レベルの正しさを保証する。比較静学はモデル全体の経済学的妥当性を検証する。両方が必要。

5. **名前付き引数とプロジェクトルール**
   パラメータの順序間違いは頻発する。これをCLAUDE.mdにルール化し、AIに徹底させる。

6. **会話履歴の記録**
   再現性のためだけでなく、自己改善のツールとして。会話履歴とgitコミットをAIに評価させることで、監督の仕方を改善できる。

### より複雑な問題への拡張

今回扱った個人の意思決定問題は、動的最適化の基本形です。しかし、同じ方法論は、より複雑な問題にも適用できます：

- **ゲーム理論**：複数プレイヤーの戦略的相互作用
- **不完備情報**：シグナルと信念の更新
- **異質エージェント**：分布の動学と総体均衡

コンセプトは同じです。数式で問題を定式化し、疑似コードで解法を設計し、段階的に実装し、比較静学で検証する。

### 実装の全公開

詳細な会話履歴、すべてのコード、レンダリングされたHTMLレポートは[GitHubリポジトリ](https://github.com/kohei-kawaguchi/TestAI)で公開しています。

特に、`docs/conversation/mdp_solver_conversation_transcript.md` は、11のフェーズにわたる完全な会話履歴であり、各段階での判断基準が「Key Learning」として記録されています。これにより、同様のプロジェクトに取り組む際の参考となります。
